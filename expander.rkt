#lang br/quicklang

(require racket/gui/base)
(require racket/draw)
(require racket/set)

; Initial values for game state
(define window-size 500)
; Number of pixels of white space between window edge and grid
(define margin 25)

; Will be set by reading in map
(define grid-size 0)
(define block-size 0)
(define block-positions (list))

(define map-vector (vector ""))
(define inner-map-index 0)

; Mutable game state tells whether or not game is won
(define game-win-flag #f)

; A hash table with keys as single char strings and values as paths to bitmaps
(define char-to-image (make-hash))

; A hash table with keys as keyboard key names and values as lists of actions to perform
(define action-table (make-hash))

; A hash table with keys as single char strings (ids) and values as lists of pairs representing their coordinates
(define position-table (make-hash))

; Hash table with keys as char ids and values as a pair of the form (interaction string, receiver)
(define interaction-table (make-hash))

; Hash table with keys as win rule symbols and values as the arguments for those rules
(define win-rule-table (make-hash))

; A struct which encapsulates an action, id is the char on the grid, dx is movement in x direction and dy is movement in y direction
(struct action (id dx dy))

; Gui setup things
(define game-frame (new frame%
                        [label "Game"]
                        [width window-size]
                        [height window-size]))

(define canvas-with-events%
  (class canvas%
    (define/override (on-char key-event)
     (handle-key-press (send key-event get-key-code)))
    (super-new)))

(define (paint-to-canvas canvas dc)
  (send dc set-pen "black" 2 'solid)
  (draw-game-grid dc window-size grid-size)
  (draw-game-state dc))

(define game-canvas (new canvas-with-events%
                         [parent game-frame]
                         [paint-callback paint-to-canvas]))

; Macros for expansion
(define-macro (puzzler-module-begin PARSE-TREE)
  #'(#%module-begin
     PARSE-TREE))
(provide (rename-out [puzzler-module-begin #%module-begin]))                               

(define-macro (puzzler-program LINE ...)
  #'(void LINE ...))
(provide puzzler-program)

; Map macros, to build map data structure
(define-macro (puzzler-map ROW ...)
  (with-pattern ([CALLER-STX (syntax->datum caller-stx)])
    #'(let ([calling-pattern 'CALLER-STX])
        (setup-draw-calculations (length (cdr calling-pattern)))
        (init-map-vector (length (cdr calling-pattern)))
        ROW ...)))
(provide puzzler-map)

(define-macro (map-row CELL ...)
  #'(build-row CELL ...))
(provide map-row)

; Draw macros, sets up char -> image map
(define-macro (draw-block RULE ...)
  #'(void RULE ...))
(provide draw-block)

(define-macro (draw-rule CHAR PATH)
  #'(add-to-image-table CHAR PATH))
(provide draw-rule)

; Action (key presses) macros
(define-macro (action-block RULE ...)
  #'(void RULE ...))
(provide action-block)

(define-macro (action-rule ID INPUT DX DY)
  #'(register-action ID INPUT DX DY))
(provide action-rule)

; Interactions macros
(define-macro (interactions-block RULE ...)
  #'(void RULE ...))
(provide interactions-block)

(define-macro (interaction-rule ACTOR INTERACTION RECEIVER)
  #'(register-interaction ACTOR INTERACTION RECEIVER))
(provide interaction-rule)

(define-macro (win-block RULE ...)
  #'(void RULE ...))
(provide win-block)

(define-macro (win-rule FIRST-ID RULE SECOND-ID)
  #'(register-win-rule FIRST-ID RULE SECOND-ID))
(provide win-rule)

; Helpers (calls generated by macros)
(define (init-map-vector len) (set! map-vector (make-vector len (vector ""))))

(define (build-row cell . rest)
  (let ([cells (cons cell rest)])
    (for-each (lambda (cell x-pos)
                (if (not (string=? cell "#"))
                    (insert-into-pos-table cell x-pos inner-map-index)
                    (void)))
              cells (build-list (length cells) values))
    (vector-set! map-vector inner-map-index (list->vector cells))
    (set! inner-map-index (add1 inner-map-index))))

(define (insert-into-pos-table value x y)
  (if (hash-has-key? position-table value)
      (hash-set! position-table value (append (hash-ref position-table value) (list (list x y))))
      (hash-set! position-table value (list (list x y)))))

(define (setup-draw-calculations rows)
  (set! grid-size rows)
  (set! block-size (quotient (- window-size (* 2 margin)) grid-size))
  (set! block-positions (build-list grid-size (lambda (i) (+ margin (* block-size i))))))

(define (draw-game-grid dc size rows)
  (let* ([grid-x-start 25]
         [grid-x-end (+ grid-x-start (- size 50))]
         [grid-y-start 25]
         [grid-y-end (+ grid-y-start (- size 50))])
    
    (send dc draw-rectangle grid-x-start grid-y-start (- size 50) (- size 50))
    (draw-rows dc grid-x-start grid-x-end grid-y-start grid-y-end rows)
    (draw-columns dc grid-x-start grid-x-end grid-y-start grid-y-end rows)))

(define (draw-rows dc x-start x-end y-start y-end rows)
  (let* ([height (- y-end y-start)]
         [row-height (quotient height rows)] ; subtract 1 from rows because we need rows-1 lines
         [row-y-values (map (lambda (x) (+ y-start (* row-height x))) (build-list (- rows 1) (lambda (y) (+ y 1))))])
    (for-each (lambda (y-value)
                (send dc draw-line x-start y-value x-end y-value))
              row-y-values)))

(define (draw-columns dc x-start x-end y-start y-end columns)
  (let* ([width (- x-end x-start)]
         [col-width (quotient width columns)]
         [col-x-values (map (lambda (x) (+ x-start (* col-width x))) (build-list (- columns 1) (lambda (y) (+ y 1))))])
    (for-each (lambda (x-value)
                (send dc draw-line x-value y-start x-value y-end))
              col-x-values)))

(define (draw-game-state dc)
  (send dc set-brush "black" 'solid)
  (for-each (lambda (y-draw grid-row)
              (for-each (lambda (x-draw grid-space)
                          (if (and (hash-has-key? char-to-image grid-space) (not (string=? grid-space "#")))
                              (let ([path (hash-ref char-to-image grid-space)])
                                (if (string=? path "rect")
                                    (send dc draw-rectangle x-draw y-draw block-size block-size)
                                    (send dc draw-bitmap (read-bitmap path) x-draw y-draw)))
                              (void)))
                        block-positions (vector->list grid-row)))
            block-positions (vector->list map-vector))
  (send dc set-brush "white" 'solid))

(define (add-to-image-table char path)
  (let* ([stripped-char (string-replace char "\"" "")]
         [stripped-path (string-replace path "\"" "")])
    (if (hash-has-key? char-to-image stripped-char)
        (error "Duplicate image characters defined!")
        (hash-set! char-to-image stripped-char stripped-path))))

(define (register-action id input dx dy)
  (let* ([stripped-id (string-replace id "\"" "")]
         [stripped-input (string-replace input "\"" "")])
    (cond
      [(hash-has-key? action-table stripped-input) (hash-set! action-table stripped-input (append (hash-ref action-table stripped-input) (action stripped-id dx dy)))]
      [else (hash-set! action-table stripped-input (list (action stripped-id dx dy)))])))

(define (update-grid-space! x y val)
  (vector-set! (vector-ref map-vector y) x val))

(define (in-bounds? x y)
  (and (>= x 0) (>= y 0) (< x grid-size) (< y grid-size)))

(define (get-grid-space x y)
  (cond
    [(in-bounds? x y) (vector-ref (vector-ref map-vector y) x)]
    [else "OOB"]))

(define (proceed-with-movement id x y dx dy)
  (hash-set! position-table id
             (map (lambda (pos)
                    (cond
                      [(and (= (first pos) x) (= (second pos) y))
                       (update-grid-space! (first pos) (second pos) "#")
                       (update-grid-space! (+ (first pos) dx) (- (second pos) dy) id)
                       (list (+ (first pos) dx) (- (second pos) dy))]
                      [else
                       (list (first pos) (second pos))]))
                  (hash-ref position-table id))))

(define (can-push? id x y dx dy)
  (let* ([dest-x (+ x dx)]
         [dest-y (- y dy)]
         [dest-val (get-grid-space dest-x dest-y)]
         [dest-val-empty? (string=? dest-val "#")])
    (cond
      ; TODO: weird pattern of #t #f #t #f, we can probably simplify this
      [dest-val-empty? (proceed-with-movement id x y dx dy) #t]
      [(not (in-bounds? dest-x dest-y)) #f]
      [(string=? (first (car (filter (lambda (i) (string=? dest-val (second i))) (hash-ref interaction-table id)))) "grab") (proceed-with-movement id x y dx dy) #t]
      [(not (string=? (first (car (filter (lambda (i) (string=? dest-val (second i))) (hash-ref interaction-table id)))) "push")) #f]
      [(can-push? id dest-x dest-y dx dy)
       (proceed-with-movement id x y dx dy) #t]
      [else #f])))
       
(define (handle-key-press key)
  (let ([key-str (~a key)])
    (if (hash-has-key? action-table key-str)
        (for-each (lambda (action)
                    (let* ([id (action-id action)]
                           [dx (string->number (action-dx action))]
                           [dy (string->number (action-dy action))])
                      (hash-set! position-table id
                                 (map (lambda (pos)
                                        (let* ([dest-x (+ (first pos) dx)]
                                               [dest-y (- (second pos) dy)]
                                               [dest-val (get-grid-space dest-x dest-y)]
                                               [interaction (filter (lambda (i) (string=? dest-val (second i))) (hash-ref interaction-table id))]
                                               [on-exit-action (filter (lambda (i) (string=? "onexit" (first i))) (hash-ref interaction-table id))] 
                                               [dest-val-empty? (string=? dest-val "#")]
                                               [has-interaction? (> (length interaction) 0)])
                                          ; This is really unmaintainable, refactor so we can handle numerous actions (especially if custom actions are coming)
                                          (cond
                                            [(or dest-val-empty? (and has-interaction? (and (string=? (first (car interaction)) "push") (can-push? dest-val dest-x dest-y dx dy))))
                                             (if (empty? on-exit-action) (update-grid-space! (first pos) (second pos) "#") (update-grid-space! (first pos) (second pos) (second (car on-exit-action))))
                                             (update-grid-space! (+ (first pos) dx) (- (second pos) dy) id)
                                             (list (+ (first pos) dx) (- (second pos) dy))]
                                            [(or dest-val-empty? (and has-interaction? (string=? (first (car interaction)) "grab")))
                                             (if (empty? on-exit-action) (update-grid-space! (first pos) (second pos) "#") (update-grid-space! (first pos) (second pos) (second (car on-exit-action))))
                                             (update-grid-space! (+ (first pos) dx) (- (second pos) dy) id)
                                             (list (+ (first pos) dx) (- (second pos) dy))]
                                            [else
                                             (list (first pos) (second pos))])))
                                      (hash-ref position-table id)))))
                  (hash-ref action-table key-str))
        (void)))
  (handle-win-rules)
  (send game-canvas refresh-now))

(define (handle-win-rules)
  (if game-win-flag
      (writeln "YOU WIN!!!")
      (for-each (lambda (rule)
                  (if (string=? rule "count_items")
                      (for-each (lambda (ids)
                              (let* ([first-id (first ids)]
                                     [second-id (second ids)]
                                     [target-count (string->number second-id)]
                                     [first-positions (hash-ref position-table first-id)])
                                (if (= target-count (length first-positions))
                                    (set! game-win-flag #t)
                                    (void))))
                                (hash-ref win-rule-table rule))
                      (for-each (lambda (ids)
                              (let* ([first-id (first ids)]
                                     [second-id (second ids)]
                                     [first-positions (hash-ref position-table first-id)]
                                     [second-positions (hash-ref position-table second-id)])
                                (if (same-position? first-positions second-positions)
                                    (set! game-win-flag #t)
                                    (void))))
                            (hash-ref win-rule-table rule))))
                  (hash-keys win-rule-table))))

(define (same-position? pos-list1 pos-list2)
  (let* ([pos-set1 (list->set pos-list1)]
         [pos-set2 (list->set pos-list2)]
         [same-positions (set-intersect pos-set1 pos-set2)])
    (> (set-count same-positions) 0)))

(define (register-interaction actor interaction receiver)
  (let* ([stripped-actor (string-replace actor "\"" "")]
         [stripped-receiver (string-replace receiver "\"" "")])
    (if (hash-has-key? interaction-table stripped-actor)
        (hash-set! interaction-table stripped-actor (append (hash-ref interaction-table stripped-actor) (list (list interaction stripped-receiver))))
        (hash-set! interaction-table stripped-actor (list (list interaction stripped-receiver))))))

(define (register-win-rule first-id rule second-id)
  (let* ([stripped-first-id (string-replace first-id "\"" "")]
         [stripped-second-id (string-replace second-id "\"" "")])
    (if (hash-has-key? win-rule-table rule)
        (hash-set! win-rule-table rule (append (hash-ref win-rule-table rule) (list (list stripped-first-id stripped-second-id))))
        (hash-set! win-rule-table rule (list (list stripped-first-id stripped-second-id))))))

(send game-frame show #t)